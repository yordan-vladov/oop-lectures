# Вектори и хешмапове

---
## Съдържание

- `std::vector` – динамична последователност
- Основни операции, итератори, капацитет
- Алгоритми от `<algorithm>` с вектори
---
- `std::unordered_map` – хеш таблица (хешмап)
- Ключове, стойности, търсене, вмъкване
- Сравнение: `unordered_map` vs `map`
- Чести грешки и добри практики
- Задачи
---
# std::vector
---
### Какво е `std::vector`?

- Динамичен масив с **непрекъсната памет** (contiguous).
- Автоматично расте при добавяне на елементи.
- Предоставя **индексиран достъп O(1)** и работа с **итератори**.
- Заглавен файл: `<vector>`.
---
```cpp
#include <vector>
#include <iostream>
using namespace std;

int main() {
    vector<int> v;           // празен вектор
    v.push_back(10);         // [10]
    v.push_back(20);         // [10, 20]
    cout << v[1] << "\n";    // 20 (без проверка)
    cout << v.at(0) << "\n"; // 10 (с проверка на граници)
}
```
---
### Основни операции

```cpp
vector<int> v = {1, 2, 3};
v.push_back(4);      // добавяне в края
v.pop_back();        // премахване от края
v.front();           // първи елемент
v.back();            // последен елемент
v.size();            // текущ брой
v.empty();           // дали е празен
v.clear();           // изчистване на всички елементи
v.insert(v.begin()+1, 99); // вмъкване
v.erase(v.begin());  // изтриване
```
---
- `operator[]` е **без проверка**; `at()` хвърля изключение при невалиден индекс.
---
### Капацитет и преоразмеряване

- `size()` – колко елемента има.    
- `capacity()` – колко елемента може да побере **преди** реалокация.
- `reserve(n)` – предварително заделя капацитет (намалява реалокациите).
- `shrink_to_fit()` – **намек** към имплементацията да свие капацитета.
- `resize(n, value)` – променя размера (добавя стойности или премахва опашка).
---
```cpp
vector<int> v;
v.reserve(1000);
for (int i = 0; i < 1000; ++i) v.push_back(i);
```
---
### Итератори и обхождане

```cpp
vector<int> v = {3, 1, 4};

// range-based for
for (int x : v) cout << x << " ";

// с итератори
for (auto it = v.begin(); it != v.end(); ++it)
    cout << *it << " ";

// модификация по референция
for (int& x : v) x *= 2;
```
---
### Вектори и `<algorithm>`

```cpp
#include <algorithm>

vector<int> v = {5, 2, 9, 1};
sort(v.begin(), v.end());                // сортиране
reverse(v.begin(), v.end());             // обръщане
auto it = find(v.begin(), v.end(), 2);   // търсене
bool any = binary_search(v.begin(), v.end(), 5); // върху сортиран вектор
```
---

### Сравнение: масив vs вектор

|Характеристика|Статичен масив `int a[N]`|`std::vector<int>`|
|---|---|---|
|Размер|Фиксиран|Динамичен|
|Памет|Stack/Static|Heap (вътрешно)|
|Проверка на граници|❌|`at()` ✅|
|Удобство|Ниско|Високо (методи/алгоритми)|

---

# std::unordered_map (хешмап)

---

### Какво е `std::unordered_map`?

- Асоциативна структура **ключ → стойност**, имплементирана като **хеш таблица**.
- Операции за търсене/вмъкване/изтриване: **очаквано O(1)**.
- Поредността **не е гарантирана** (за разлика от `map`).
- Заглавен файл: `<unordered_map>`.
---
```cpp
#include <unordered_map>
#include <string>
#include <iostream>
using namespace std;

int main() {
    unordered_map<string, int> freq;
    freq["apple"]++;      // вмъква "apple":0 и увеличава → 1
    freq["banana"] = 3;
    cout << freq.at("banana") << "\n";   // 3 (хвърля при липса)
    if (auto it = freq.find("pear"); it != freq.end())
        cout << it->second << "\n";
}
```

---
### Добавяне, достъп и изтриване

```cpp
unordered_map<int, string> idToName;

idToName.emplace(42, "Ada"); // преференция: emplace пред insert за конструиране на място
idToName.insert({7, "Linus"});

cout << idToName[7];         // достъп/създава default при липса!
idToName.erase(42);          // трие по ключ
idToName.clear();            // изчиства
```
---
- Използвай `find()` + `it->second` или `contains(key)` (C++20), когато **не искаш** да създаваш запис:
```cpp
if (idToName.contains(7)) { /* ... */ }
```

---

### Итерация през `unordered_map`

```cpp
unordered_map<string,int> freq = {{"a",2},{"b",5}};

for (const auto& [k, v] : freq) {    // структурирано разопаковане (C++17)
    cout << k << " = " << v << "\n";
}
```
---
- Ключовете са **уникални**.
- При rehash/растеж **итераторите се инвалидизират**
---
### Контрол на производителността

- **Load factor** = размер / брой кофи (buckets). Висок → повече колизии.
- `rehash(nBuckets)` – сменя броя кофи.
- `reserve(n)` – планирай капацитет по броя **елементи** (по-удобно).
- Добър хеш → по-малко колизии → по-бърз достъп.
---
```cpp
unordered_map<string,int> freq;
freq.reserve(10000);  // по-малко rehash при масово вмъкване
```
---

### `unordered_map` vs `map`

| Характеристика   | `unordered_map`               | `map` (червено-черно дърво)     |
| ---------------- | ----------------------------- | ------------------------------- |
| Сложност търсене | Очаквано O(1)                 | O(log N)                        |
| Подреденост      | Не                            | Да (по ключ)                    |
| Итерация по ред  | ❌                             | ✅                               |
| Използване       | Бърз достъп по ключ           | Нужен подреден ключ/диапазони   |
| Памет            | Повече overhead (кофи/хешове) | По-компактно спрямо хеш таблица |

---
# Чести грешки и практики
---
### Вектор – валидност на референции/итератори

- **След реалокация** (напр. `push_back` след изчерпан капацитет) **всички** указатели/итератори към елементи стават **невалидни**.
- Решение: `reserve()` предварително или пази **индекси**, не указатели.
---
### Хешмап – неволно създаване на стойности

```cpp
unordered_map<string,int> m;
int x = m["missing"]; // създава ключ "missing" със стойност 0!
```

- Използвай `find()`/`contains()` или `at()` за само четене без създаване.
---
### Константност и авто

- Предпочитай `const auto&` при обхождане, за да избегнеш копирания.
- Прави интерфейси, които приемат `span`/`const vector<>&` вместо „сурови“ масиви.
---
# Примери

---

### Поддържане на честоти с `unordered_map`

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<string> words = {"a","b","a","c","b","a"};
    unordered_map<string,int> freq;
    freq.reserve(words.size());
    for (const auto& w : words) freq[w]++;
    // Топ-2 по честота
    vector<pair<string,int>> items(freq.begin(), freq.end());
    partial_sort(items.begin(), items.begin()+2, items.end(),
                 [](auto& a, auto& b){ return a.second > b.second; });
    for (int i=0;i<2;i++) cout << items[i].first << ": " << items[i].second << "\n";
}
```

---
### Стабилно сортиране на индекси вместо елементи

```cpp
vector<int> v = {40, 10, 30, 20};
vector<int> idx(v.size());
iota(idx.begin(), idx.end(), 0);  // 0,1,2,3
stable_sort(idx.begin(), idx.end(),
    [&](int i, int j){ return v[i] < v[j]; });
// обхождаш v по сортирани индекси, без да чупиш стабилни референции
```
---
# Сложност (накратко)

---

### `std::vector`

| Операция                     | Сложност          |
| ---------------------------- | ----------------- |
| Индексиран достъп (`v[i]`)   | O(1)              |
| `push_back` (амортизирано)   | O(1) амортизирано |
| Вмъкване/изтриване в средата | O(N)              |
| Сортиране                    | O(N log N)        |

---
### `std::unordered_map`

| Операция              | Очаквана сложност |
| --------------------- | ----------------- |
| Търсене (`find`)      | O(1)              |
| Вмъкване (`emplace`)  | O(1)              |
| Изтриване (`erase`)   | O(1)              |
| Итериране през всички | O(N)              |

> Забележка: В най-лош случай при лош хеш – O(N).

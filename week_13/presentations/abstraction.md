# Абстракция и интерфейси в C++

---

## Какво е абстракция?

* Един от основните принципи на ООП.
* Позволява ни да:

  * скрием сложните вътрешни детайли;
  * покажем само **важните операции/функции**;
  * работим с обект чрез неговия **контракт**, а не чрез имплементацията.

---

## Основна идея

> Потребителят на класа трябва да знае *какво прави*, а не *как го прави*.

---

## Как се постига абстракция в C++?

Чрез:

* **Абстрактни класове**
* **Чисто виртуални функции**
* **Интерфейси (класове без имплементация)**

---

# Абстрактни класове

* Клас, който съдържа **поне една чисто виртуална функция**.
* Не може да се създава обект от него.
* Служи като **модел/шаблон** за производните класове.

---

### Пример

```cpp
class Device {
public:
    virtual void start() = 0;  // чисто виртуална функция
    virtual void stop() = 0;   // чисто виртуална функция
    virtual ~Device() = default;
};
```

---

## Чисто виртуална функция

```cpp
virtual void start() = 0;
```

* Няма тяло → само **обещание**, че наследниците ще я реализират.
* Създава *контракт* – какво трябва да може всеки „Device“.

---

# Интерфейси в C++

C++ **няма отделна ключова дума** `interface` като Java/C#.

Но интерфейсът се реализира чрез:

* Клас, който съдържа само **чисто виртуални функции**;
* Няма член-данни или има минимални (константни);
* Има виртуален деструктор.

---

### Пример: интерфейс за зареждаемо устройство

```cpp
class IRechargeable {
public:
    virtual void recharge() = 0;
    virtual int batteryLevel() const = 0;
    virtual ~IRechargeable() = default;
};
```

* `I` като префикс е честа практика (не е задължителна).

---

# Пример: Реализация на интерфейс

```cpp
class Phone : public Device, public IRechargeable {
public:
    void start() override {
        std::cout << "Phone starting...\n";
    }

    void stop() override {
        std::cout << "Phone shutting down...\n";
    }

    void recharge() override {
        battery = 100;
        std::cout << "Phone recharged.\n";
    }

    int batteryLevel() const override {
        return battery;
    }

private:
    int battery = 50;
};
```

---

# Полиморфизъм чрез интерфейси

* Когато имаме указател/референция към интерфейс:

```cpp
IRechargeable* r = new Phone();
r->recharge();
std::cout << r->batteryLevel();
delete r;
```

* Функциите се извикват полиморфно (по реалния тип на обекта).

---

# Множествено наследяване за интерфейси

C++ **позволява** множествено наследяване.

* При интерфейси това е полезно, защото:

  * те нямат член-данни;
  * няма риск от конфликт на имплементация.

> Използвайте множествено наследяване **само за интерфейси**, а не за класове с поведение.

---

# Абстракция vs. Инкапсулация

| Абстракция                                  | Инкапсулация                          |
| ------------------------------------------- | ------------------------------------- |
| Скриване на *детайли*                       | Скриване на *данни*                   |
| Създава концептуален модел                  | Постига безопасност и контрол         |
| Работи чрез интерфейси и абстрактни класове | Работи чрез private/protected членове |

---

# Добри практики

* Всеки интерфейс описва **една** отговорност (SRP).
* Не смесвайте интерфейси с логика.
* Използвайте `override` за по-голяма сигурност.
* Използвайте `= default` за виртуални деструктори.
* Не добавяйте член-данни в интерфейси без силна причина.

---

# Обобщение

* Абстракцията позволява работа с концепции, а не конкретна реализация.
* Интерфейсите се реализират чрез чисто виртуални класове.
* Чистите виртуални функции дефинират **какво трябва да се направи**.
* Производните класове дефинират **как се прави**.
* Интерфейсите насърчават гъвкав и разширяем код.

---

# 4. **Задача: Система от устройства и интерфейси**

Създайте проект със следната структура:

```text
project/
├─ include/
│  ├─ Device.h
│  ├─ IRechargeable.h
│  ├─ Phone.h
│  ├─ Laptop.h
├─ src/
│  ├─ Phone.cpp
│  ├─ Laptop.cpp
│  ├─ main.cpp
├─ CMakeLists.txt
```

---

## Изисквания:

### 1. `Device` – абстрактен клас

Съдържа:

* `virtual void start() = 0;`
* `virtual void stop() = 0;`
* виртуален деструктор.

---

### 2. `IRechargeable` – интерфейс

Съдържа:

* `virtual void recharge() = 0;`
* `virtual int batteryLevel() const = 0;`
* виртуален деструктор.

---

### 3. `Phone` и `Laptop` – класове, които:

* наследяват `Device`;
* имплементират `IRechargeable`;
* поддържат вътрешно състояние на батерията.

Примерно:

```cpp
void recharge() override { battery = 100; }
```

---

### 4. В `main.cpp`:

* създайте масив/вектор от `Device*`;
* добавете `Phone` и `Laptop`;
* демонстрирайте полиморфизъм чрез:

  * `start()`, `stop()`;
  * ако обектът е `IRechargeable`, извикайте `recharge()`.

---

### 5. Използвайте CMake, за да:

* компилирате отделните `.cpp` файлове;
* генерирате изпълним файл.


# Абстракция и интерфейси в C++

---
### Какво е абстракция?

* Един от основните принципи на ООП.
* Позволява ни да:

  * скрием сложните вътрешни детайли;
  * покажем само **важните операции/функции**;
  * работим с обект чрез неговия **контракт**, а не чрез имплементацията.

---

### Основна идея

> Потребителят на класа трябва да знае *какво прави*, а не *как го прави*.

---

### Как се постига абстракция в C++?

Чрез:

* **Абстрактни класове**
* **Чисто виртуални функции**
* **Интерфейси (класове без имплементация)**

---

### Абстрактни класове

* Клас, който съдържа **поне една чисто виртуална функция**.
* Не може да се създава обект от него.
* Служи като **модел/шаблон** за производните класове.

---

### Пример

```cpp
class Device {
public:
    virtual void start() = 0;  // чисто виртуална функция
    virtual void stop() = 0;   // чисто виртуална функция
    virtual ~Device() = default;
};
```

---

### Чисто виртуална функция

```cpp
virtual void start() = 0;
```

---
* Няма тяло → само **обещание**, че наследниците ще я реализират.
* Създава *контракт* – какво трябва да може всеки „Device“.

---
### Интерфейси в C++

C++ **няма отделна ключова дума** `interface` като Java/C#.

---
Но интерфейсът се реализира чрез:

* Клас, който съдържа само **чисто виртуални функции**;
* Няма член-данни или има минимални (константни);
* Има виртуален деструктор.

---

### Пример: интерфейс за зареждаемо устройство

```cpp
class IRechargeable {
public:
    virtual void recharge() = 0;
    virtual int batteryLevel() const = 0;
    virtual ~IRechargeable() = default;
};
```

* `I` като префикс е честа практика (не е задължителна).

---

### Пример: Реализация на интерфейс

```cpp
class Phone : public Device, public IRechargeable {
public:
    void start() override {
        std::cout << "Phone starting...\n";
    }

    void stop() override {
        std::cout << "Phone shutting down...\n";
    }

    void recharge() override {
        battery = 100;
        std::cout << "Phone recharged.\n";
    }

    int batteryLevel() const override {
        return battery;
    }

private:
    int battery = 50;
};
```

---

### Полиморфизъм чрез интерфейси

* Когато имаме указател/референция към интерфейс:

```cpp
IRechargeable* r = new Phone();
r->recharge();
std::cout << r->batteryLevel();
delete r;
```

* Функциите се извикват полиморфно (по реалния тип на обекта).

---

### Множествено наследяване за интерфейси

C++ **позволява** множествено наследяване.

* При интерфейси това е полезно, защото:
  * те нямат член-данни;
  * няма риск от конфликт на имплементация.

> Използвайте множествено наследяване **само за интерфейси**, а не за класове с поведение.

---
### Използване на `std::unique_ptr` с интерфейси и полиморфизъм

---

### Защо да използваме smart pointers?

Проблеми при сурови указатели (`Device*`):

* Трябва ръчно да извикваме `delete`.
* Лесно се получават:

  * **memory leak** (забравен `delete`);
  * **double delete**;
  * висящи указатели (dangling pointers).

**Решение:** използваме `std::unique_ptr` – автоматично управление на паметта.

---

### Какво е `std::unique_ptr`?

* Smart pointer, който:

  * **притежава** динамично заделен обект;
  * не може да бъде копиран → само **един собственик**;
  * обектът се изтрива **автоматично**, когато `unique_ptr` излезе от обхват.

---

### Пример: полиморфизъм с `unique_ptr<Device>`

```cpp
#include <memory>
#include <vector>

int main() {
    std::vector<std::unique_ptr<Device>> devices;

    devices.push_back(std::make_unique<Phone>());
    devices.push_back(std::make_unique<Laptop>());

    for (auto& d : devices) {
        d->start();
    }

    // Няма нужда от delete – извиква се автоматично
    return 0;
}
```

* `std::make_unique<Phone>()` създава обект в heap и го „опакова“ в `unique_ptr`.
* Полиморфизмът работи по същия начин – извиква се виртуалната функция според реалния тип.

---

### Комбинация: `unique_ptr` и интерфейси

Можем да имаме `unique_ptr` към **интерфейс**:

```cpp
std::unique_ptr<IRechargeable> r = std::make_unique<Phone>();

r->recharge();
std::cout << r->batteryLevel() << "\n";
```

* Отново → **няма ръчен `delete`**.
* Деструкторът на `Phone` ще се извика коректно, ако интерфейсът има **виртуален деструктор**.

---

### Проверка дали обектът имплементира интерфейс

При `unique_ptr` можем да използваме `dynamic_cast` върху суровия указател:

```cpp
for (auto& d : devices) {
    d->start();

    if (auto* rechargeable = dynamic_cast<IRechargeable*>(d.get())) {
        rechargeable->recharge();
        std::cout << "Battery: " << rechargeable->batteryLevel() << "%\n";
    }

    d->stop();
}
```

* `d.get()` връща суров указател към обекта (без да променя собствеността).
* Използваме полиморфизъм и интерфейси, а управлението на паметта пак е автоматизирано.

---

### Добри практики с `unique_ptr` и полиморфизъм

* Използвайте `std::make_unique<T>()` вместо `new`.
* Държете **собствеността** с `std::unique_ptr`, но:

  * подавайте обекти към функции като `Device&` или `Device*`, когато няма прехвърляне на собственост.
* Уверете се, че базовите класове (`Device`, интерфейси) имат **виртуални деструктори**.
* Използвайте `auto&` при обхождане на `std::vector<std::unique_ptr<...>>`.

---

### Обобщение за `unique_ptr` + интерфейси

* `std::unique_ptr` решава основни проблеми с паметта при полиморфизъм.
* Работи прекрасно с:

  * абстрактни базови класове (`Device`);
  * интерфейси (`IRechargeable`).
* Полиморфизмът се запазва, а `delete` изчезва от кода.
* Това е **препоръчителният модерен подход** в C++ при работа с динамично полиморфни обекти.

---

### Абстракция vs. Инкапсулация

| Абстракция                                  | Инкапсулация                          |
| ------------------------------------------- | ------------------------------------- |
| Скриване на *детайли*                       | Скриване на *данни*                   |
| Създава концептуален модел                  | Постига безопасност и контрол         |
| Работи чрез интерфейси и абстрактни класове | Работи чрез private/protected членове |

---

### Добри практики

* Всеки интерфейс описва **една** отговорност (SRP).
* Не смесвайте интерфейси с логика.
* Използвайте `override` за по-голяма сигурност.
* Използвайте `= default` за виртуални деструктори.
* Не добавяйте член-данни в интерфейси без силна причина.

---

### Обобщение

* Абстракцията позволява работа с концепции, а не конкретна реализация.
* Интерфейсите се реализират чрез чисто виртуални класове.
* Чистите виртуални функции дефинират **какво трябва да се направи**.
* Производните класове дефинират **как се прави**.
* Интерфейсите насърчават гъвкав и разширяем код.

---

# 4. **Задача: Система от устройства и интерфейси**

Създайте проект със следната структура:

```text
project/
├─ include/
│  ├─ Device.h
│  ├─ IRechargeable.h
│  ├─ Phone.h
│  ├─ Laptop.h
├─ src/
│  ├─ Phone.cpp
│  ├─ Laptop.cpp
│  ├─ main.cpp
├─ CMakeLists.txt
```

---

## Изисквания:

### 1. `Device` – абстрактен клас

Съдържа:

* `virtual void start() = 0;`
* `virtual void stop() = 0;`
* виртуален деструктор.

---

### 2. `IRechargeable` – интерфейс

Съдържа:

* `virtual void recharge() = 0;`
* `virtual int batteryLevel() const = 0;`
* виртуален деструктор.

---

### 3. `Phone` и `Laptop` – класове, които:

* наследяват `Device`;
* имплементират `IRechargeable`;
* поддържат вътрешно състояние на батерията.

Примерно:

```cpp
void recharge() override { battery = 100; }
```

---

### 4. В `main.cpp`:

* създайте масив/вектор от `Device*`;
* добавете `Phone` и `Laptop`;
* демонстрирайте полиморфизъм чрез:

  * `start()`, `stop()`;
  * ако обектът е `IRechargeable`, извикайте `recharge()`.

---

### 5. Използвайте CMake, за да:

* компилирате отделните `.cpp` файлове;
* генерирате изпълним файл.

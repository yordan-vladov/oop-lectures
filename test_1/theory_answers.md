# Развити въпроси за контролно

## Структури, класове и референтни типове

### 1. Какво представлява структура в C++ и за какво се използва?

**Структурата (`struct`)** в C++ е **потребителски дефиниран тип данни**, който позволява обединяване на няколко логически свързани променливи в една обща структура. Така програмистът може да моделира реални обекти или записи от данни по по-ясен и организиран начин, вместо да използва множество отделни променливи. Всеки елемент в структурата се нарича **член (member)** и има собствен тип.

Основна особеност на структурата в C++ е, че **всички нейни членове са публични (`public`) по подразбиране**. Това означава, че до тях може да се осъществява директен достъп от всяка част на програмата. Поради тази причина `struct` често се използва, когато целта е просто да се съхраняват данни, без да се налага строг контрол върху достъпа до тях.

Структурите могат да съдържат не само данни, но и **функции (методи)**, конструктори и деструктори. Въпреки това, по конвенция те се използват предимно за **пасивни обекти**, при които логиката е минимална, а основният фокус е върху групирането на информация. Когато структурата няма потребителски дефинирани конструктори и всички членове са публични, тя може да се инициализира директно чрез **списък за инициализация (aggregate initialization)**, което прави кода кратък и четим.

На практика структурите се използват за представяне на **записи (records)** – например координатна точка, дата, студент, елемент от таблица или ред от файл. Те са особено удобни в начални курсове по програмиране, при работа с данни, както и в ситуации, където сложната обектно-ориентирана логика не е необходима. По този начин `struct` служи като ясен и ефективен инструмент за моделиране на данни в C++.

### 2. Какво представлява клас в C++ и за какво се използва?

**Класът (`class`)** в C++ е основна конструкция на обектно-ориентираното програмиране, която позволява създаването на **абстрактни модели на обекти от реалния свят**, комбиниращи данни и поведение. Класът дефинира какви данни ще съдържа един обект и какви операции могат да се извършват върху тези данни. От класа могат да се създават **обекти (инстанции)**, които представляват конкретни реализации на описания модел.

Съществена характеристика на класа е, че **членовете му са `private` по подразбиране**. Това означава, че вътрешните данни не могат да бъдат достъпвани директно отвън, а само чрез специално дефиниран публичен интерфейс. Този подход позволява **скриване на реализацията** и предпазва обекта от некоректни промени, като по този начин гарантира, че той винаги остава в валидно състояние.

Класовете дават възможност за реализиране на **инкапсулация**, което е един от основните принципи на обектно-ориентираното програмиране. Чрез публични методи (member functions) програмистът контролира как и кога данните могат да бъдат четени или променяни. Това позволява въвеждане на проверки, ограничения и бизнес логика, които не биха били възможни при директен достъп до данните.

Освен това класовете поддържат **конструктори и деструктори**, които автоматично се грижат за инициализацията и освобождаването на ресурси. Това е особено важно при работа с динамична памет, файлове, мрежови връзки и други ресурси, които изискват стриктно управление. Класовете могат също да имат оператори, статични членове, наследяване и полиморфизъм, което ги прави мощен инструмент за изграждане на сложни и мащабируеми системи.

На практика класовете се използват, когато е необходимо да се моделират **обекти с поведение**, а не само да се съхраняват данни. Те са предпочитаният избор при по-големи проекти, където кодът трябва да бъде лесен за поддръжка, разширяване и повторна употреба. Чрез класовете C++ предоставя механизъм за създаване на надежден, структуриран и добре организиран софтуер.

### 3. Какво е конструктор в C++? Какви са различните типове конструктори и разликите между тях?

**Конструкторът** в C++ е специална член-функция на клас или структура, която се извиква **автоматично при създаване на обект**. Неговата основна роля е да **инициализира обекта** и да гарантира, че той започва съществуването си в **валидно и предвидимо състояние**. Конструкторът носи същото име като класа, няма тип на връщане и не може да бъде извикван като обикновена функция – той се задейства единствено при създаване на обекта.

Най-простият вид е **конструкторът по подразбиране (default constructor)**. Той се извиква, когато обектът се създава без аргументи. Ако програмистът не дефинира такъв, компилаторът може автоматично да генерира конструктор по подразбиране, стига това да е възможно. Този тип конструктор често се използва за начална инициализация със стандартни стойности и може изрично да бъде поискан чрез `= default`.

Друг широко използван тип е **конструкторът с параметри**. Той приема аргументи и позволява инициализацията на обекта с конкретни стойности още при създаването му. Това е предпочитаният начин за инициализация, защото предотвратява съществуването на обекти в невалидно или частично инициализирано състояние. Обикновено този тип конструктор използва **списък за инициализация**, който е по-ефективен от присвояване в тялото на конструктора.

**Копиращият конструктор (copy constructor)** се използва, когато нов обект се създава като копие на вече съществуващ обект от същия тип. Той се извиква при инициализация чрез друг обект, при подаване на обект по стойност във функция или при връщане на обект по стойност. Основната му задача е да създаде **независимо копие** на оригиналния обект, като коректно копира всички негови ресурси.

С въвеждането на C++11 се появява **преместващият конструктор (move constructor)**. Той приема rvalue референция и позволява „преместване“ на ресурси от временен обект към новия, вместо тяхното копиране. Това води до значително по-добра производителност, особено при работа с динамична памет или големи обекти. След преместването, изходният обект остава в валидно, но неопределено състояние.

Разликата между различните видове конструктори се състои основно в **начина на инициализация и управлението на ресурсите**. Докато конструкторът по подразбиране създава обект със стандартни стойности, параметризираният конструктор позволява прецизна инициализация. Копиращият конструктор създава нов обект чрез дублиране на съществуващ, а преместващият конструктор оптимизира процеса чрез прехвърляне на ресурси. Заедно с операторите за присвояване те формират т.нар. **Rule of Three / Rule of Five**, която описва правилното управление на ресурси в класовете на C++.

### 4. Какво е деструктор в C++? За какво най-често се използват деструкторите?

**Деструкторът** в C++ е специална член-функция на клас или структура, която се извиква **автоматично при унищожаване на обект**. Унищожаването настъпва, когато обектът излезе от обхвата си (scope), когато бъде изтрит с оператора `delete`, или при приключване на програмата за глобални и статични обекти. Името на деструктора съвпада с името на класа, предшествано от символа `~`, и той няма параметри и тип на връщане.

Основното предназначение на деструктора е **освобождаването на ресурси**, които обектът е заделил по време на своето съществуване. Такива ресурси могат да бъдат динамично заделена памет, отворени файлове, мрежови връзки, сокети, mutex-и или други системни ресурси. Ако тези ресурси не бъдат освободени навреме, програмата може да доведе до изтичане на памет или блокиране на системни ресурси.

Деструкторите са тясно свързани с концепцията **RAII (Resource Acquisition Is Initialization)**. Според този принцип всеки ресурс трябва да бъде придобит в конструктора и освободен в деструктора. По този начин управлението на ресурсите става автоматично и сигурно, без необходимост от ръчно освобождаване във всяка точка на програмата. Това значително намалява риска от грешки и прави кода по-надежден.

В практиката деструкторите се използват най-често при класове, които управляват външни ресурси. Например клас за работа с файл ще затвори файла в деструктора си, клас за динамичен масив ще освободи заделената памет, а клас за синхронизация ще освободи съответните заключвания. Ако класът не управлява ресурси, често няма нужда от ръчно дефиниран деструктор, тъй като компилаторът може автоматично да генерира такъв.

Важно е да се отбележи, че деструкторът се извиква **в обратен ред на създаване на обектите**, което е особено съществено при композиция на обекти. Освен това, при използване на наследяване, деструкторът на базовия клас обикновено трябва да бъде деклариран като `virtual`, за да се гарантира правилното унищожаване на обектите. Така деструкторите играят ключова роля за коректното и безопасно управление на ресурсите в C++.

### 5. Какво представлява инкапсулация?

**Инкапсулацията** е един от основните принципи на обектно-ориентираното програмиране и представлява **скриване на вътрешните данни и реализацията на даден обект**, като достъпът до тях се осъществява само чрез ясно дефиниран публичен интерфейс. Целта на инкапсулацията е да се предпази обектът от неправилна употреба и да се гарантира, че той винаги се намира в коректно и валидно състояние.

В C++ инкапсулацията се реализира чрез **спецификаторите за достъп** `private`, `protected` и `public`. Обикновено член-данните на класа се декларират като `private`, което означава, че те не могат да бъдат променяни директно извън класа. Достъпът до тях се осъществява чрез `public` методи (напр. getter-и и setter-и), които могат да съдържат проверки, ограничения и допълнителна логика. По този начин се осигурява контрол върху начина, по който данните се използват.

Основно предимство на инкапсулацията е **защитата на инвариантите** на класа. Инвариантите са условия, които винаги трябва да са изпълнени за даден обект (например балансът на банкова сметка да не бъде отрицателен или температурата да не пада под абсолютната нула). Чрез инкапсулация тези правила се прилагат на едно място – в методите на класа – и не могат да бъдат нарушени от външен код.

Инкапсулацията допринася и за **по-добра поддръжка и разширяемост на кода**. Тъй като вътрешната реализация е скрита, тя може да бъде променяна, оптимизирана или изцяло подменяна, без това да засяга кода, който използва класа. Външният свят разчита единствено на публичния интерфейс, което намалява зависимостите между отделните части на програмата.

## Класове - добри практики

### 1. Какво представляват `get` и `set` методите и за какво се използват?

**Getter (`get`) и Setter (`set`) методите** са публични методи на класа, които се използват за **достъп** и **промяна** на частните член-променливи. Те са пряко свързани с принципа **капсулация**, който е основен в обектно-ориентираното програмиране.

Понеже член-променливите обикновено се декларират като `private`, външният код **няма директен достъп** до тях. Това предпазва обекта от неконтролирани промени и гарантира, че той винаги ще бъде в **валидно състояние**. Именно тук идва ролята на `get` и `set` методите – те са „вратата“, през която външният код комуникира с данните на обекта.

**Getter методите** се използват за **извличане на стойности** от обекта. Те връщат текущото състояние на дадена член-променлива, без да я променят. Поради тази причина getter-ите почти винаги се декларират като **`const` методи**, което гарантира, че извикването им няма да промени състоянието на обекта и позволява използването им и върху `const` обекти.

**Setter методите** се използват за **промяна на стойностите** на член-променливите. Тяхното основно предимство е, че позволяват да се добави **валидация** и допълнителна логика при задаване на стойности. Например чрез setter може да се забрани задаването на отрицателна цена, да се хвърли изключение или да се коригира подадената стойност. Така се гарантира, че обектът няма да попадне в некоректно състояние.

Използването на `get` и `set` методи прави кода **по-четим, по-сигурен и по-лесен за поддръжка**. Ако по-късно се наложи промяна в начина на съхранение или проверка на данните, това може да стане само в методите, без да се променя външният код, който използва класа. Това е една от основните причини getter-ите и setter-ите да се считат за **добра практика** при проектиране на класове в C++.

### 2. Какво представлява `to_string()` методът и за какво се използва?

Методът **`to_string()`** представлява **член-метод на класа**, който връща **текстово (низово) представяне на обект** от този клас. Обикновено той връща стойност от тип `std::string`, която описва текущото състояние на обекта по разбираем за човека начин. Въпреки че C++ не изисква задължително наличието на такъв метод, използването му се счита за **добра практика**.

Основната цел на `to_string()` метода е да **обедини на едно място логиката за представяне на обекта като текст**. Вместо във всяка част на програмата да се извеждат поотделно член-променливите с `cout`, методът предоставя единен и стандартизиран начин за извеждане на информацията за обекта.

`to_string()` методът се използва най-често при:

- извеждане на информация на екрана (`cout`);
- записване в логове;
- дебъгване на програми;
- отпечатване на обекти в текстови файлове;
- по-ясна визуализация на данните по време на разработка.
    

Тъй като `to_string()` само **чете данните на обекта**, без да ги променя, той почти винаги се декларира като **`const` метод**. Това гарантира, че извикването му няма да промени състоянието на обекта и позволява използването му и върху `const` обекти.

Едно от основните предимства на `to_string()` е, че **подобрява четимостта на кода**. Вместо сложни и дълги изрази в `main()` или в други функции, програмата става по-ясна и интуитивна, тъй като извикването `object.to_string()` ясно показва намерението на програмиста.

Освен това, ако по-късно се наложи промяна във формата на извеждане (например добавяне на ново поле или промяна на подредбата), това може да се направи **само в `to_string()` метода**, без да се променя останалият код. Това улеснява поддръжката и развитието на програмата и е още една причина методът да бъде широко използван в добре проектирани C++ класове.

### 3. Какво са константни (`const`) методи и за какво се използват?

**Константните методи** са член-методи на класа, които **гарантират, че няма да променят състоянието на обекта**, върху който са извикани. Те се декларират чрез добавяне на ключовата дума `const` след списъка с параметри на метода.

```cpp
string getName() const;
```

С поставянето на `const` програмистът изрично заявява, че методът има само **информационна роля** и не извършва промени по член-променливите на обекта.

Основното предназначение на константните методи е да осигурят **безопасен достъп до данните** на обекта. Вътре в такъв метод не е позволено да се променят член-променливите (освен ако не са декларирани като `mutable`). Това се проверява от компилатора и предотвратява неволни грешки в логиката на програмата.

Много важно свойство на `const` методите е, че **могат да се извикват върху константни обекти**. Ако даден обект е деклариран като `const`, върху него могат да се извикват **само константни методи**. Това налага правилно проектиране на интерфейса на класа и ясно разделение между методи, които променят състоянието, и такива, които само го четат.

```cpp
const Student s{"Ivan"};
cout << s.getName(); // валидно
```

Използването на константни методи подобрява **четимостта и самодокументацията на кода**. Когато видим метод с `const`, веднага знаем, че той няма странични ефекти и няма да промени обекта. Това улеснява работата в екип и прави кода по-надежден.

Константните методи са особено важни при реализацията на **getter-и**, оператори за сравнение, методи за извеждане (`to_string()`), както и при работа със стандартните контейнери и алгоритми на C++, които често изискват `const` коректност.

### 4. Какво са статични членове и статични методи?

**Статичните членове и статичните методи** са елементи на класа, които **принадлежат на самия клас**, а не на отделните обекти, създадени от него. Това означава, че те се **споделят от всички инстанции** на класа и съществуват независимо от броя на създадените обекти.

**Статичните член-променливи** се използват, когато е необходимо да се съхранява информация, обща за всички обекти. За разлика от обикновените членове, които всеки обект притежава отделно, статичният член има **една единствена стойност**, валидна за целия клас. Типичен пример е брояч на всички създадени обекти от даден клас.

Статичните член-променливи се декларират вътре в класа, но се **инициализират извън него**, обикновено в `.cpp` файла. Това е необходимо, защото паметта за тях се заделя само веднъж.

```cpp
class Car {
    static int totalCars;
};

int Car::totalCars = 0;
```

**Статичните методи** са методи, които също принадлежат на класа, а не на конкретен обект. Те **нямат достъп до указателя `this`**, тъй като не са свързани с конкретна инстанция. Поради това статичните методи могат да работят **само със статични член-променливи** или с данни, подадени като параметри.

Статичните методи се извикват чрез **името на класа**, а не чрез обект, което ясно показва, че действието е свързано с класа като цяло.

```cpp
Car::getTotalCars();
```

Най-честите приложения на статичните членове и методи са:

* броене на създадени обекти;
* съхраняване на общи настройки или константи;
* помощни функции, логически свързани с класа;
* реализиране на фабрични методи.

Използването на статични членове и методи подобрява **структурата и логиката на програмата**, като ясно отделя поведението и данните, които са общи за всички обекти, от тези, които са специфични за всяка отделна инстанция. Това води до по-ясен, по-поддържаем и по-добре организиран код.

### 5. Какво представляват правилото на 3 и правилото на 5 (Rule of 3 / Rule of 5)?

Правилото на 3 и правилото на 5 са фундаментални принципи в C++, които описват **как трябва да се държат класовете, когато управляват ресурси**. Под ресурси се разбират динамично заделена памет, файлове, мрежови връзки, дескриптори и други обекти, които изискват изрично освобождаване. Целта на тези правила е да се предотвратят грешки като изтичане на памет, двойно освобождаване и некоректно копиране на обекти.

Правилото на 3 (Rule of 3) гласи, че ако един клас дефинира **поне един** от следните специални методи – копиращ конструктор, копиращ оператор за присвояване или деструктор – то най-вероятно трябва да дефинира **и трите**. Причината е, че тези методи са логически свързани и заедно отговарят за коректното управление на ресурсите по време на жизнения цикъл на обекта.

Копиращият конструктор се използва, когато се създава нов обект като копие на съществуващ. При класове с ресурси той трябва да извършва **дълбоко копиране**, тоест да задели собствен ресурс за новия обект, а не просто да копира адреси. Ако това не се направи, два обекта могат да сочат към един и същ ресурс, което води до сериозни проблеми.

Копиращият оператор за присвояване (`operator=`) се извиква, когато на вече съществуващ обект се присвоява стойността на друг обект. Той трябва да се справи коректно със самоприсвояване, да освободи стария ресурс и да копира новия по безопасен начин. Неправилна реализация често води до изтичане на памет или нестабилно поведение на програмата.

Деструкторът има задачата да **освободи всички заделени ресурси**, когато обектът излезе от обхват или бъде унищожен. Ако класът управлява ресурс, но няма собствен деструктор, компилаторът няма как да знае какво трябва да освободи, което почти винаги води до изтичане на ресурси.

С въвеждането на C++11 и семантиката на преместване, правилото на 3 е разширено до **правилото на 5 (Rule of 5)**. Освен трите вече споменати метода, се добавят още два – преместващ конструктор и преместващ оператор за присвояване. Те позволяват ресурсите да бъдат **прехвърляни**, вместо копирани, когато работим с временни обекти.

Преместващият конструктор се използва, когато нов обект се създава от временен такъв. Вместо да заделя нов ресурс и да копира данни, той просто „отнема“ ресурса от временния обект, което е значително по-бързо. Преместващият оператор за присвояване изпълнява същата идея, но при присвояване между обекти.

На практика правилата на 3 и 5 служат като **ориентир при проектиране на класове**. Ако класът не управлява ресурси, най-добрият подход е да се използват автоматично генерираните от компилатора методи чрез `= default`. Ако пък копирането не е желано, то може изрично да бъде забранено с `= delete`.

## C++ - организация на кода

### 1. Какво представляват **header** (`.h`, `.hpp`) файлове?

**Header файловете** в C++ са специални файлове, които съдържат **декларации** и описват интерфейса на даден модул, клас или библиотека. Тяхната основна цел е да покажат _какви функции, класове и типове данни са налични_, без да разкриват тяхната вътрешна реализация. По този начин header файловете отделят интерфейса от имплементацията и правят кода по-ясен и структуриран.

Основна характеристика на header файловете е, че те се **включват** в други файлове чрез директивата `#include`. Когато компилаторът срещне `#include`, съдържанието на съответния header файл логически се „вмъква“ на това място. Това позволява различни `.cpp` файлове да използват едни и същи декларации, без да дублират код.

В header файловете обикновено се съдържат **декларации на класове**, **прототипи на функции**, **структури**, **enumeration-и**, както и глобални константи. При класовете се описват публичните, защитените и частните членове, но без реалната логика на методите. Изключение правят `inline` функциите и шаблоните (templates), които по необходимост се дефинират изцяло в header файлове.

Важно правило е, че header файловете **не трябва да съдържат тежка логика** или реални имплементации на функции. Причината е, че един header може да бъде включен в много различни `.cpp` файлове. Ако в него има дефиниции, това може да доведе до грешки при линкване (multiple definition). Затова реалният код почти винаги се намира в `.cpp` файловете.

Друга ключова роля на header файловете е да служат като **документация на интерфейса**. Добре написаният header файл ясно показва как се използва даден клас или функция, какви параметри приема и какъв резултат връща. В този смисъл header файлът е основната отправна точка за всеки програмист, който използва даден модул или библиотека.

За да се избегне проблемът с **многократното включване** на един и същ header файл, се използват include guards или директивата `#pragma once`. Те гарантират, че съдържанието на header файла ще бъде обработено само веднъж по време на компилация, независимо колко пъти е включено.

### 2. Какво представляват **изходни** (`.cpp`) файлове?

**Изходните файлове** в C++ (с разширение `.cpp`) съдържат **реалната имплементация** на програмата. В тях се описва _как работи_ дадена функционалност, дефинират се алгоритмите и логиката на приложението. Ако header файловете показват „какво съществува“, то `.cpp` файловете показват „как е реализирано“.

Всеки `.cpp` файл представлява **самостоятелна компилационна единица**. Това означава, че компилаторът обработва всеки такъв файл поотделно и създава обектен файл (`.o` или `.obj`). По-късно всички обектни файлове се обединяват от линкера в едно изпълнимо приложение или библиотека. Този модел позволява частична прекомпилация – при промяна само на един `.cpp` файл не е необходимо целият проект да се компилира отново.

В `.cpp` файловете обикновено се включват съответните **header файлове** чрез директивата `#include`. По този начин компилаторът знае какви функции, класове и типове данни се използват, докато реалните дефиниции се намират именно в `.cpp` файла. Това гарантира коректна връзка между декларациите и имплементациите.

Основното съдържание на изходните файлове са **дефинициите на функции** и **методите на класовете**. Когато в header файл е обявен даден клас или функция, техният реален код почти винаги се намира в съответния `.cpp` файл. Така се постига ясно разделение между интерфейс и реализация, което улеснява четенето и поддръжката на кода.

В `.cpp` файловете се намира и **основната логика на програмата**, включително функцията `main()`, която е входната точка на приложението. Често `main.cpp` координира работата на останалите модули, като използва класове и функции, дефинирани в други `.cpp` файлове.

Ограничаването на имплементацията само в `.cpp` файловете има и важна практическа роля – **скриване на детайли**. Потребителят на даден клас или библиотека не е нужно да знае как точно е реализирана логиката, а само как да я използва. Това подобрява сигурността, стабилността и възможността за промени без засягане на останалия код.

### 3. Как е прието да се организират **header** и **source** файловете в C++ проектите?

В C++ проектите е прието кодът да бъде организиран по начин, който улеснява **четенето, поддръжката и разширяването** на приложението. Добрата структура на файловете позволява на програмиста бързо да се ориентира в проекта и ясно показва кои части от кода представляват интерфейс и кои – имплементация. Това е особено важно при по-големи проекти и при работа в екип.

Най-разпространената практика е **физическото разделяне** на header и source файловете в различни директории. Обикновено header файловете се поставят в директория `include/`, а source файловете – в директория `src/`. Това разделение ясно показва кои файлове са предназначени за използване от други модули или проекти и кои съдържат вътрешната реализация на програмата.

Често използвана структура на проект изглежда така:

```text
project/
├─ include/
│  ├─ ClassA.h
│  ├─ ClassB.h
├─ src/
│  ├─ ClassA.cpp
│  ├─ ClassB.cpp
│  ├─ main.cpp
```

В тази структура имената на `.h` и `.cpp` файловете обикновено **съвпадат с името на класа или модула**, който съдържат. Това правило улеснява навигацията и прави проекта по-интуитивен за разбиране.

Прието е **един клас или логически модул** да бъде реализиран в **един header и един source файл**. Header файлът описва публичния интерфейс – какво може да се използва, а source файлът съдържа реалната имплементация. Този подход предотвратява смесването на отговорности и прави кода по-лесен за тестване и промяна.

В по-големите проекти структурата може да бъде разширена с **поддиректории по модули или функционалности**. Например всеки модул може да има собствена папка в `include/` и `src/`. Това позволява проектът да расте, без да се превръща в хаотична колекция от файлове, и улеснява повторното използване на цели модули като библиотеки.

Добрата организация на header и source файловете е тясно свързана и с използването на **build системи**, като CMake. Чрез ясно подредена структура build системата лесно намира необходимите файлове, управлява зависимостите и компилира проекта по ефективен начин. Това прави процеса на компилация по-надежден и преносим между различни платформи.

### 4. Какво е библиотека в C++ проектите? Какви са различните видове библиотеки?

В C++ проектите **библиотеката** представлява организирана колекция от код, която реализира определена функционалност и може да бъде използвана от едно или повече приложения. Вместо един и същ код да се пише многократно, той се обособява в библиотека и се **преизползва** в различни проекти. Това води до по-чист код, по-добра поддръжка и по-бърза разработка.

Библиотеките обикновено съдържат **header файлове**, които описват публичния интерфейс (какво може да се използва), и **компилиран код**, който реализира функционалността. Програмата, която използва библиотеката, включва нейните header-и и се **линква** към готовия код. По този начин детайлите на реализацията остават скрити за потребителя на библиотеката.

Основна причина за използването на библиотеки е **модулността**. Големите C++ проекти се разделят на по-малки логически части – например модул за математика, модул за работа с файлове или модул за мрежова комуникация. Всеки от тези модули може да бъде реализиран като отделна библиотека, което улеснява тестването, поддръжката и разширяването на проекта.

В зависимост от начина на свързване с програмата, библиотеките в C++ се разделят основно на **статични** и **динамични**.

**Статичната библиотека** съдържа предварително компилиран код, който се **включва директно** в изпълнимия файл по време на линкване. В резултат на това крайният `.exe` файл става по-голям, но не зависи от външни файлове при стартиране. Статичните библиотеки са удобни за по-малки проекти и за приложения, които трябва да се разпространяват лесно без допълнителни зависимости.

**Динамичната библиотека** се зарежда по време на изпълнение на програмата. В този случай изпълнимият файл съдържа само препратки към библиотеката, а реалният код се намира в отделен файл (`.dll` под Windows или `.so` под Linux). Това позволява няколко програми да използват една и съща библиотека и улеснява обновяването ѝ без прекомпилация на всички приложения, но изисква библиотеката да е налична при стартиране.

Изборът между статична и динамична библиотека зависи от конкретните изисквания на проекта – размер на приложението, начин на разпространение, честота на обновяване и нужда от споделяне на код между различни програми. В практиката и двата типа библиотеки се използват широко, като често един проект комбинира няколко библиотеки от различен тип.

### 5. Какво представлява CMake и за какво се използва?

**CMake** е инструмент за управление на процеса по компилация на C++ (и други) проекти, който се използва като **генератор на build системи**. Той не компилира кода директно, а създава файлове за конкретна build среда – например Makefiles, проекти за Visual Studio, Ninja или други системи. По този начин CMake действа като междинен слой между изходния код и конкретния компилатор или IDE.

Основната идея на CMake е компилацията да бъде описана по **платформено независим начин**. Вместо да се пишат различни build скриптове за Windows, Linux и macOS, разработчикът описва структурата на проекта в един или няколко файла `CMakeLists.txt`. След това CMake автоматично генерира подходящите build файлове според използваната платформа и компилатор.

Във файла `CMakeLists.txt` се описва **какви цели (targets)** има проектът – изпълними файлове и библиотеки, от кои `.cpp` файлове се състоят, какви header директории използват и какви зависимости имат помежду си. Така CMake управлява връзките между отделните части на проекта и гарантира, че те ще бъдат компилирани и линкнати в правилния ред.

CMake значително улеснява работата с **библиотеки**. С негова помощ могат лесно да се създават статични и динамични библиотеки, както и да се линкват към различни приложения. Освен това CMake позволява повторно използване на библиотеки в други проекти, без да е необходимо ръчно конфигуриране на компилатора и линкера.

Друго важно предимство на CMake е, че подобрява **мащабируемостта и поддръжката** на проектите. При добавяне на нови файлове или модули е необходимо само да се актуализира конфигурацията, без да се променят сложни компилационни команди. Това прави CMake особено подходящ за големи и дългосрочни проекти, както и за екипна разработка.

CMake е и де факто **индустриален стандарт** в съвременното C++ програмиране. Много популярни библиотеки и frameworks използват CMake като основна build система, което го прави задължително умение за всеки C++ разработчик. Той улеснява интеграцията с различни IDE-та и автоматизира процесите по компилация и линкване.

## C++ - наследяване

### 1. Какво представлява наследяване в C++?

Наследяването в C++ е фундаментален механизъм на обектно-ориентираното програмиране, който позволява създаването на нови класове на основата на вече съществуващи. Тези нови класове се наричат производни, а класовете, от които произлизат – базови. Чрез наследяването се изграждат логически връзки между класовете и се постига по-добра структурираност и йерархия на програмния код.

Едно от основните предимства на наследяването е повторното използване на код. Общата функционалност се дефинира в базовия клас и автоматично става достъпна за всички негови наследници. Това намалява дублирането на код, улеснява поддръжката и позволява разширяване на програмата чрез добавяне на нови класове, без да се налагат промени в вече реализирани компоненти.

Наследяването моделира логическата връзка „е вид“ между класовете. Ако един клас наследява друг, то всеки обект от производния клас може да бъде разглеждан като обект от базовия клас. Това позволява използването на производни обекти там, където се очаква базов тип, което е ключово за гъвкавостта и разширяемостта на програмите.

Производният клас наследява публичните и защитените членове на базовия клас, докато частните членове остават недостъпни директно. По този начин се запазва принципът на инкапсулация, като базовият клас контролира кои свои части предоставя за използване и разширяване от наследниците си.

Наследяването е основа за реализиране на полиморфизъм в C++. Чрез него базовият клас дефинира общ интерфейс, а производните класове могат да предлагат собствена реализация на определени методи. Това позволява работа с различни обекти по унифициран начин, като конкретното поведение се определя динамично по време на изпълнение на програмата.

В процеса на софтуерно проектиране наследяването се използва за изграждане на ясни и логически обосновани класови йерархии. То трябва да се прилага само когато съществува реална концептуална връзка „е вид“ между класовете, тъй като неправилната му употреба може да доведе до твърда свързаност и затруднена поддръжка на кода.

### 2. Какви са различните видове наследяване в C++ и разликите между тях?

В C++ наследяването може да се реализира по три различни начина – `public`, `protected` и `private`, като изборът на типа наследяване определя как нивата на достъп на членовете от базовия клас се променят в производния клас. Това е важен механизъм за контрол на достъпа и за дефиниране на това как базовият клас ще бъде „видим“ за външния свят чрез своите наследници.

При `public` наследяване публичните членове на базовия клас остават публични в производния клас, а защитените остават защитени, докато частните членове не са директно достъпни. Този тип наследяване запазва публичния интерфейс на базовия клас и позволява производният клас да бъде използван навсякъде, където се очаква базовият. Поради това `public` наследяването е най-често използваният вариант и е основата за реализиране на полиморфизъм в C++.

При `protected` наследяване публичните и защитените членове на базовия клас стават защитени в производния клас. Това означава, че те са достъпни само вътре в йерархията от наследници, но не и от външния код. Този тип наследяване се използва по-рядко и е подходящ в ситуации, когато базовият клас служи като помощен или вътрешен компонент, който не трябва да бъде част от публичния интерфейс на производния клас.

При `private` наследяване както публичните, така и защитените членове на базовия клас стават частни в производния клас. По този начин връзката между базовия и производния клас се скрива напълно от външния свят. Макар да е позволено в C++, този тип наследяване се използва рядко, тъй като често може да бъде заменен с композиция, която предлага по-голяма гъвкавост и по-слаба свързаност между класовете.

Сравнявайки трите типа наследяване, може да се заключи, че `public` наследяването изразява ясно концепцията „е вид“ и е стандартният избор при проектиране на класови йерархии. `protected` и `private` наследяването по-скоро служат за повторно използване на реализация, отколкото за изграждане на логическа връзка между типовете. Затова в практиката и в обучението по C++ в преобладаващата част от случаите се използва именно `public` наследяване.

### 3. Как се извикват констукторите и деструкторите на базовия клас в C++?

При използване на наследяване в C++ конструкторите и деструкторите на класовете се извикват в строго определен ред, който гарантира коректно и безопасно създаване и унищожаване на обектите. Този ред е пряко свързан с йерархията на класовете и начина, по който един клас надгражда друг.

При създаване на обект от производен клас първо винаги се извиква конструкторът на базовия клас, а след това конструкторът на производния. Причината за това е, че производният клас използва базовия като основа и той трябва да бъде напълно инициализиран, преди да се добави специфичното поведение и състояние на наследника. По този начин се гарантира, че всички член-данни, наследени от базовия клас, са в коректно състояние още в началото на съществуването на обекта.

При унищожаване на обектът редът на извикване е обратен. Първо се изпълнява деструкторът на производния клас, а след това деструкторът на базовия. Това позволява на производния клас да освободи собствените си ресурси, преди базовата част на обекта да бъде разрушена. Така се избягват ситуации, в които производният клас би се опитал да използва вече унищожени ресурси от базовия.

Редът на извикване на конструкторите и деструкторите е автоматично управляван от езика C++ и не може да бъде променян от програмиста. Независимо от това, разработчикът трябва да е наясно с този механизъм, особено когато класовете управляват ресурси като динамична памет, файлове или мрежови връзки. Неправилното разбиране на този ред може да доведе до грешки и изтичане на ресурси.

Особено важно е използването на виртуален деструктор в базовите класове, когато обектите ще бъдат унищожавани чрез указател към базов тип. В противен случай може да се извика само деструкторът на базовия клас, което води до некоректно освобождаване на ресурсите, заделени от производния клас. Затова добавянето на виртуален деструктор в базовия клас е добра практика при проектиране на класови йерархии.
### 4. Как е правилно да се имплементират параметризираните конструктори в производните класове?

При наследяване в C++ много често базовият клас няма конструктор по подразбиране или изисква определени параметри за правилната си инициализация. В такива случаи производният клас е длъжен да осигури коректно извикване на конструктора на базовия клас, като подаде необходимите аргументи още при създаването на обекта.

Правилният начин за подаване на параметри към конструктора на базовия клас е чрез т.нар. списък за инициализация на конструктора на производния клас. Списък за инициализация се намира след двоеточието в дефиницията на конструктора и се използва за инициализация както на базовия клас, така и на член-данните на производния. Тъй като базовият клас се конструира преди тялото на конструктора, този механизъм е единственият коректен начин за предаване на параметри към него.

Важно е да се разбере, че инициализацията на базовия клас не може да се извърши в тялото на конструктора на производния клас. Опит за извикване на конструктора на базовия клас вътре в тялото не води до повторна инициализация, а до създаване на временен обект, което е логическа грешка. Затова използването на списък за инициализация не е просто добра практика, а задължително изискване при параметризирани базови конструктори.

Списък за инициализация се използва не само за базовия клас, но и за всички член-данни, които трябва да бъдат инициализирани директно, като константни членове или членове от типове без конструктор по подразбиране. Това прави кода по-ефективен, тъй като се избягва първоначална инициализация по подразбиране, последвана от присвояване.

При проектиране на класови йерархии е добра практика всеки производен клас ясно да дефинира какви параметри приема и как ги предава към базовия клас. Това води до по-четим код и по-лесна поддръжка, тъй като зависимостите между класовете са ясно изразени още в декларацията на конструктора.
### 5. Какво представлява полиморфизъм и как се имплементира в C++?

Полиморфизмът е основна концепция в обектно-ориентираното програмиране и означава „много форми“, при което един и същ интерфейс може да се използва за обекти от различни типове. В C++ полиморфизмът позволява работа с различни обекти чрез общ базов клас, като конкретното поведение се определя от реалния тип на обекта по време на изпълнение на програмата.

Реализацията на полиморфизъм в C++ е тясно свързана с наследяването и използването на виртуални функции. Базовият клас дефинира методи като `virtual`, което позволява на производните класове да ги презапишат със собствена реализация. Когато такъв метод се извиква чрез указател или референция към базовия клас, C++ избира правилната версия на функцията в зависимост от действителния тип на обекта, а не от типа на променливата.

За разлика от динамичното свързване при полиморфизма, при липса на виртуални функции C++ използва статично свързване. В този случай извикването на метода се определя още по време на компилация според типа на указателя или референцията. Това означава, че дори обектът да е от производен клас, ще бъде извикана версията на функцията от базовия клас, ако методът не е деклариран като виртуален.

За по-голяма безопасност и четимост на кода C++ предоставя ключовата дума `override`, която се използва в производните класове. Тя указва изрично, че даден метод трябва да презаписва виртуална функция от базовия клас. Ако подписът на функцията не съвпада, компилаторът ще сигнализира за грешка, което помага за избягване на трудно откриваеми логически проблеми.

Полиморфизмът е тясно свързан и с използването на виртуални деструктори. Когато обекти от производни класове се унищожават чрез указател към базов клас, виртуалният деструктор гарантира, че първо ще бъде извикан деструкторът на производния клас, а след това този на базовия. Това е особено важно при управление на ресурси и предотвратяване на изтичане на памет.

Абстрактните класове и чисто виртуалните функции са разширение на концепцията за полиморфизъм. Те позволяват дефиниране на общ интерфейс без конкретна реализация, като задължават производните класове да имплементират необходимото поведение. По този начин полиморфизмът в C++ осигурява гъвкавост, разширяемост и възможност за изграждане на стабилни и лесни за поддръжка софтуерни системи.

## C++ -  абстракция, интерфейси

### 1. Какво е абстрактен клас в C++

**Абстрактният клас** в C++ е клас, който служи като **базов модел** за други класове и не може да бъде инстанциран директно. Неговата основна цел е да дефинира _какви операции трябва да поддържат_ всички производни класове, без да налага конкретна реализация. Така абстрактният клас описва **концепция**, а не конкретен обект.

Абстрактен клас се получава тогава, когато в него има **поне една чисто виртуална функция**. Чисто виртуалната функция се декларира чрез `= 0` и няма тяло. Тя представлява обещание, че всеки клас, който наследява абстрактния клас, **задължително трябва да реализира** тази функция, за да може да бъде създаден обект от него.

Поради наличието на чисто виртуални функции, **не може да се създава обект** от абстрактен клас. Въпреки това, той може да се използва чрез **указатели или референции**, които сочат към обекти от производни класове. Това е основата на полиморфизма в C++ и позволява работа с различни реализации чрез общ базов тип.

Абстрактните класове често съдържат **виртуален деструктор**. Това е изключително важно, когато обектите се унищожават чрез указател към базов клас. Виртуалният деструктор гарантира, че първо ще се извика деструкторът на конкретния (производния) клас, а след това и този на базовия, което предотвратява течове на памет и некоректно освобождаване на ресурси.

На практика абстрактният клас играе ролята на **контракт между базовия и производните класове**. Той определя минималния набор от функции, които всяка реализация трябва да предлага. По този начин кодът става по-гъвкав, по-лесен за разширяване и по-независим от конкретните реализации.

### 2. Какво представлява абстракцията и как се имплементира в C++

**Абстракцията** е един от основните принципи на обектно-ориентираното програмиране и има за цел да опише _същността на един обект_, като се фокусира върху това **какво прави**, а не върху това **как е реализиран**. Чрез абстракцията програмистът работи с общи концепции и логика, без да се натоварва с вътрешните детайли на реализацията.

Основната идея на абстракцията е **скриване на сложността**. Потребителят на даден клас вижда само публичния интерфейс – методите, които може да извиква – докато реалният начин на работа, използваните алгоритми и вътрешни структури от данни остават скрити. Това прави кода по-четим, по-безопасен и по-лесен за поддръжка.

В C++ абстракцията най-често се имплементира чрез **абстрактни класове** и **чисто виртуални функции**. Абстрактният клас дефинира общо поведение чрез виртуални методи, а чисто виртуалните функции задават задължителни операции, които всеки наследник трябва да реализира. По този начин се дефинира ясен _контракт_ между базовия клас и неговите производни.

Друг важен механизъм за абстракция в C++ са т.нар. **интерфейсни класове**. Макар езикът да няма отделна ключова дума `interface`, интерфейсът се реализира като клас, съдържащ само чисто виртуални функции и виртуален деструктор. Такива класове описват способности или роли (например „зареждаемо устройство“), без да налагат конкретна реализация.

Абстракцията в C++ е тясно свързана с **полиморфизма**. Когато работим с указател или референция към базов абстрактен клас, можем да извикваме виртуални функции, които се изпълняват според реалния тип на обекта. Това позволява писане на гъвкав и разширяем код, при който нови класове могат да бъдат добавяни без промяна на съществуващата логика.

### 3. Какво е интерфейс и как се имплементира в C++

**Интерфейсът** представлява абстрактен договор, който описва _какви операции един клас трябва да предоставя_, без да задава как те са реализирани. Той дефинира поведение, което различни класове могат да споделят, независимо от това дали са свързани помежду си чрез наследяване на реална функционалност. По този начин интерфейсът описва **способности или роли**, а не конкретен тип обект.

В C++ няма специална ключова дума `interface`, както в езици като Java или C#. Вместо това интерфейсът се реализира чрез **абстрактен клас**, който съдържа **само чисто виртуални функции**. Тези функции нямат имплементация и служат единствено за дефиниране на публичния контракт, който производните класове трябва да изпълнят.

Типичният интерфейс в C++ **не съдържа член-данни**, тъй като целта му не е да съхранява състояние, а да дефинира поведение. В редки случаи могат да присъстват константни стойности или минимални помощни елементи, но това не е обичайна практика. За правилно управление на паметта интерфейсният клас задължително трябва да има **виртуален деструктор**.

Имплементацията на интерфейс се осъществява чрез **наследяване**. Класът-наследник е длъжен да реализира всички чисто виртуални функции на интерфейса. Ако това не бъде направено, класът остава абстрактен и от него не може да се създава обект. Често се използва конвенцията името на интерфейса да започва с `I` (например `IRechargeable`), за по-лесно разграничаване от класове с реална логика.

Интерфейсите са особено полезни при **полиморфизъм**. Когато работим с указател или референция към интерфейс, можем да извикваме дефинираните в него функции, без да знаем конкретния тип на обекта. Това позволява кодът да бъде слабо свързан и лесен за разширяване, тъй като нови класове могат да имплементират интерфейса без промяна на съществуващия код.

### 4. Как може да се създаде обект в програмния **stack** и в програмния **heap**? Кога се използва едното и кога другото?

В C++ обектите могат да се създават в две основни области на паметта – **stack (стек)** и **heap (динамична памет)**. Изборът къде да бъде създаден един обект влияе върху неговия жизнен цикъл, начина на управление на паметта и дизайна на програмата.

Създаването на обект в **stack** става чрез директна декларация на променлива. Такъв обект се създава автоматично при влизане в съответния обхват (scope) и се унищожава автоматично при излизане от него. Управлението на паметта е напълно автоматично и не изисква намесата на програмиста, което прави този подход по-безопасен и по-ефективен.

Обектите в **heap** се създават динамично по време на изпълнение на програмата. Класически това става чрез оператора `new`, но в модерния C++ се препоръчва използването на **smart pointers**, като `std::unique_ptr` или `std::shared_ptr`. При динамичните обекти животът не е обвързан със scope-а, в който са създадени, а продължава докато паметта не бъде освободена.

Основната разлика между stack и heap е **контролът върху жизнения цикъл на обекта**. Stack-обектите имат кратък и ясно определен живот, докато heap-обектите могат да съществуват по-дълго и да бъдат споделяни между различни части на програмата. Това прави heap-паметта особено полезна при работа с полиморфизъм и динамични структури от данни.

Stack-паметта се използва най-често, когато размерът на обекта е известен предварително, обектът не е твърде голям и не е необходимо той да съществува извън текущия обхват. Тя е по-бърза и по-малко податлива на грешки като течове на памет, тъй като освобождаването става автоматично.

Heap-паметта се използва, когато е необходима по-голяма гъвкавост – например при съхранение на обекти в колекции, при динамичен полиморфизъм (работа с базови указатели към производни обекти) или когато животът на обекта трябва да се контролира ръчно или чрез smart pointers. В такива случаи използването на `std::unique_ptr` е препоръчителният и безопасен подход.

### 5. Какво представлява множественото наследяване в C++? Защо се избягва и кога може да се използва?

**Множественото наследяване** в C++ е механизъм, при който един клас може да наследява **повече от един базов клас**. Това означава, че производният клас получава достъп до интерфейсите и (при наличие) имплементациите на всички свои базови класове. Синтактично това се реализира чрез изброяване на повече от един базов клас в декларацията на класа.

Въпреки че езикът C++ поддържа множествено наследяване, то **често се избягва** в практиката, защото може да доведе до усложняване на дизайна. Основният проблем е т.нар. _diamond problem_ (ромбовиден проблем), при който два базови класа наследяват общ предшественик. В такъв случай може да възникне двусмислие коя версия на наследения член да бъде използвана, както и дублиране на данни в обекта.

Освен ромбовидния проблем, множественото наследяване може да доведе и до **конфликти на имена**, неочаквано поведение при виртуални функции и по-сложна структура на обекта в паметта. Това прави кода по-труден за разбиране, отстраняване на грешки и поддръжка, особено в големи проекти или при екипна работа.

Поради тези причини в повечето случаи се предпочитат алтернативи като **композиция** (has-a връзка) или използване на единично наследяване, което води до по-ясна архитектура. Композицията позволява комбиниране на поведение чрез обекти-членове, без да се създават сложни йерархии от класове.

Съществува обаче важен и широко приет случай, в който множественото наследяване е **уместно и безопасно** – когато се използва **само за интерфейси**. Интерфейсните класове не съдържат член-данни и реална логика, а само чисто виртуални функции. В този контекст множественото наследяване позволява един клас да имплементира няколко роли или способности, без риск от конфликт на имплементация.

# Пойнтъри, референции и динамична памет
---
## Съдържание

- Пойнтъри – адреси и оператори `&` и `*`
- Разлика между указатели и референции
- Функции с указатели
- Динамични масиви и оператори `new` / `delete`
- Задачи
---
# Пойнтъри
---
### Какво е пойнтър?

- **Пойнтър (указател)** е променлива, която **съхранява адрес** в паметта.
- Може да сочи към:
    - друга променлива
    - масив
    - обект
- С помощта на пойнтъри можем **индиректно** да достъпваме и променяме стойности.
---
### Операторите `&` и `*`

- `&` → **оператор за адрес** – връща адреса на променлива
- `*` → **оператор за разименование (dereference)** – достъп до стойността на адреса
---
```cpp
#include <iostream>
using namespace std;

int main() 
{
    int x = 10;
    int* p = &x;     // p сочи към x
    cout << "Адресът на x: " << p << endl;
    cout << "Стойност чрез пойнтър: " << *p << endl;

    *p = 20;          // променя x
    cout << "Новата стойност на x: " << x << endl;
}
```
---

### Тип на пойнтъра
- Типът определя как се интерпретира адресът:

```cpp
int* p1;    // сочи към int
double* p2; // сочи към double
char* p3;   // сочи към char
```
---
- Всеки пойнтър трябва да се инициализира:

```cpp
int* ptr = nullptr;  // безопасна инициализация
```
---
# Референции
---
### Какво е референция?

- **Референция** е **друго име** за съществуваща променлива.
- Създава се с `&` при декларацията:
```cpp
int a = 5;
int& ref = a;
ref = 10;  // променя a
```
---
### Разлики между пойнтър и референция

| Характеристика                       | Пойнтър           | Референция   |
| ------------------------------------ | ----------------- | ------------ |
| Може да е `nullptr`                  | ✅ Да              | ❌ Не         |
| Може да сочи към друго нещо по-късно | ✅ Да              | ❌ Не         |
| Изисква `*` за достъп                | ✅ Да              | ❌ Не         |
| Необходимост от инициализация        | Не е задължително | Задължително |

---
### Пример

```cpp
#include <iostream>
using namespace std;

int main() 
{
    int x = 10;
    int* p = &x;
    int& r = x;

    cout << "x = " << x << endl;
    *p = 20;
    cout << "След *p = 20 → x = " << x << endl;
    r = 30;
    cout << "След r = 30 → x = " << x << endl;
}
```

---
# Функции с пойнтъри

---
### Предаване на адрес

- Може да предаваме адрес вместо стойност → промените важат и извън функцията.

```cpp
#include <iostream>
using namespace std;

void increment(int* p) 
{
    (*p)++;
}

int main() 
{
    int num = 5;
    increment(&num);
    cout << "След функцията: " << num << endl; // 6
}
```
---

### Предаване по референция

```cpp
void increment(int& ref) 
{
    ref++;
}
```

- Референциите са по-четими и по-безопасни, но **не могат да бъдат пренасочвани**.
---
### Функции, връщащи пойнтър

```cpp
int* getMax(int* a, int* b)
{
    if (*a > *b) return a;
    else return b;
}

int main()
{
    int x = 4, y = 9;
    int* maxPtr = getMax(&x, &y);
    cout << "По-голямото: " << *maxPtr << endl;
}
```

---
# Динамична памет
---
### Операторите `new` и `delete`

- Използват се за **динамично заделяне на памет**.
- Паметта се освобождава ръчно с `delete`.

```cpp
int* p = new int;  // заделя 1 int
*p = 10;
cout << *p;
delete p;          // освобождава паметта
```
---
### Динамични масиви

```cpp
int n;
cout << "Въведете размер: ";
cin >> n;

int* arr = new int[n];  // динамичен масив

for(int i = 0; i < n; i++)
    arr[i] = i + 1;

for(int i = 0; i < n; i++)
    cout << arr[i] << " ";

delete[] arr;  // освобождаване
```

---
### Пример с функция

```cpp
void fillArray(int* arr, int size)
{
    for(int i=0; i<size; i++)
        arr[i] = (i+1)*10;
}

int main()
{
    int n = 5;
    int* data = new int[n];
    fillArray(data, n);

    for(int i=0; i<n; i++)
        cout << data[i] << " ";

    delete[] data;
}
```
---
# Статични и динамични масиви

---

### Какво е статичен масив?

- Размерът му се **задава при компилация** (фиксиран).    
- Съхранява се **в стека (stack)**.
- Паметта се освобождава **автоматично**, когато променливата излезе от обхват.
---
```cpp
int arr[5];          // статичен масив
int nums[3] = {1,2,3};
```

- Не може да се промени дължината по време на изпълнение.    

---
- **Предимства:**
    - По-бърз достъп (фиксирана памет)
    - Без нужда от `new` / `delete`
    - Автоматично управление на паметта
---
- **Недостатъци:**
    - Размерът е постоянен
    - Неудобни при работа с данни с променлива дължина
---
### Какво е динамичен масив?

- Размерът се задава **по време на изпълнение (runtime)**.
- Съхранява се **в динамичната памет (heap)**.
- Управлява се ръчно с операторите `new` и `delete[]`.
---
```cpp
int n;
cout << "Въведете размер: ";
cin >> n;

int* arr = new int[n];  // динамичен масив

for (int i = 0; i < n; i++)
    arr[i] = i + 1;

delete[] arr;  // задължително освобождаване
```
---

- **Предимства:**
    - Гъвкав размер
    - Подходящи при големи или неизвестни обеми данни
- **Недостатъци:**
    - Трябва **ръчно** да се освобождава паметта 
    - По-бавно създаване и достъп
    - Риск от **memory leak** (изтичане на памет) при забравен `delete[]`
---
### Сравнение

| Характеристика   | Статичен масив          | Динамичен масив     |
| ---------------- | ----------------------- | ------------------- |
| Размер           | Фиксиран (compile time) | Променлив (runtime) |
| Памет            | Stack                   | Heap                |
| Освобождаване    | Автоматично             | Ръчно (`delete[]`)  |
| Гъвкавост        | ❌ Ниска                 | ✅ Висока            |
| Производителност | ✅ По-бърз               | ⚠️ Малко по-бавен   |

---
### Пример: сравнение в код

```cpp
#include <iostream>
using namespace std;

int main()
{
    // Статичен масив
    int staticArr[3] = {1, 2, 3};

    // Динамичен масив
    int n;
    cout << "Размер: ";
    cin >> n;
    int* dynamicArr = new int[n];

    for (int i = 0; i < n; i++)
        dynamicArr[i] = i * 10;

    cout << "Динамичен масив: ";
    for (int i = 0; i < n; i++)
        cout << dynamicArr[i] << " ";

    delete[] dynamicArr;  // освобождаваме паметта
}
```

---
# Задачи
---

1. Декларирайте пойнтър към цяло число и променете стойността на променлива чрез него.
2. Напишете функция, която **разменя две числа** чрез пойнтъри.
3. Напишете функция, която намира **сумата на елементите** на масив чрез пойнтър.
4. Създайте **динамичен масив**, въведете `n` числа и изчислете **средната стойност**.
5. Реализирайте функция, която създава и връща **динамичен масив** от квадратите на първите `N` числа.
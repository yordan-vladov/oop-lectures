# Валидация на данните, валидация на входа и изключения

---

## Съдържание

* Какво е валидация на данните?
* Валидация на **входа** от конзолата (`std::cin`)
* Обработка на грешки и състояния на потока
* Изключения в C++: `throw` / `try` / `catch`
* Йерархия на стандартните изключения
* Добри практики и примери
* Задачи

---

# Какво е валидация?

---

### Дефиниция

* **Валидация** = проверка дали дадени данни са **коректни, пълни и в допустими граници** преди да бъдат използвани.
* Цел: да **предотврати грешки**, **крашове** и **невалидни изчисления**.

---

### Видове валидация

* **Синтактична** (формат): например „въведете цяло число“.
* **Семантична** (смисъл): числото да е в **диапазон** (напр. 1–100).
* **Крос-валидация**: зависимост между полета (напр. `start < end`).

---

# Валидация на входа (конзола)

---

### Проблем: `std::cin` и некоректен вход

* При въвеждане на **нечислов** текст в `int`, потокът влиза в **състояние на грешка**.
* Необходимо е **изчистване** на флаговете и **изхвърляне** на грешните символи от буфера.

```cpp
#include <iostream>
#include <limits>
using namespace std;

int readInt() {
    int x;
    while (true) {
        cout << "Въведете цяло число: ";
        if (cin >> x) return x;                 // успех
        cout << "Невалиден вход! Опитайте отново.\n";
        cin.clear();                             // 1) чистим флагове
        cin.ignore(numeric_limits<streamsize>::max(), '\n'); // 2) чистим буфера
    }
}

int main() {
    int n = readInt();
    cout << "Въведохте: " << n << "\n";
}
```

---

### Проверка на диапазон

```cpp
int readIntInRange(int lo, int hi) {
    while (true) {
        int v = readInt();
        if (v >= lo && v <= hi) return v;
        cout << "Стойността трябва да е в диапазон [" << lo << ", " << hi << "]\n";
    }
}
```

---

### Четене на ред и парсване

* Понякога е по-сигурно да четем **цяла линия** и после да я **парсваме**.

```cpp
#include <string>
#include <sstream>

int readIntLine() {
    string line;
    while (true) {
        cout << "int = ";
        if (!getline(cin, line)) throw runtime_error("Входът приключи неочаквано");
        stringstream ss(line);
        int v; char extra;
        if (ss >> v && !(ss >> extra)) return v; // няма остатъчни символи
        cout << "Невалиден формат. Опитайте пак.\n";
    }
}
```

---

# Състояния на потока

---

### Флагове

| Флаг     | Значение                      |
| -------- | ----------------------------- |
| `good()` | Няма грешка                   |
| `fail()` | Форматна грешка               |
| `bad()`  | Сериозна грешка (I/O проблем) |
| `eof()`  | Достигнат край на файла/входа |

* `cin.clear()` премахва `fail/bad/eof` флаговете.
* `cin.ignore(...)` пропуска остатъчни символи.

---

# Изключения в C++

---

### Идея

* **Изключение** = сигнал за необичаен случай по време на изпълнение.
* Механизъм: `throw` → търси се подходящ `catch` в стек-а на извикванията.
---
```cpp
#include <stdexcept>

int divide(int a, int b) {
    if (b == 0) throw std::invalid_argument("Деление на нула");
    return a / b;
}

int main() {
    try {
        cout << divide(10, 0) << "\n";
    } catch (const std::invalid_argument& ex) {
        cout << "Грешка: " << ex.what() << "\n";
    }
}
```

---

### Йерархия (частична)

* `std::exception`
  * `std::logic_error`
    * `std::invalid_argument`
    * `std::out_of_range`
  * `std::runtime_error`
    * `std::overflow_error`
    * `std::underflow_error`

---

### Множество catch блокове

```cpp
try {
    // код, който може да хвърли
} catch (const std::out_of_range& e) {
    cerr << "Индекс извън диапазон: " << e.what() << "\n";
} catch (const std::exception& e) {
    cerr << "Друга грешка: " << e.what() << "\n";
}
```

---

# Комбиниране: валидация + изключения

---
### Валидираме, преди да хвърлим

```cpp
int parsePort(const std::string& s) {
    // очакваме 0..65535
    size_t pos = 0;
    long long v = stoll(s, &pos);
    if (pos != s.size()) throw invalid_argument("Неподдържани символи");
    if (v < 0 || v > 65535) throw out_of_range("Портът е извън [0,65535]");
    return static_cast<int>(v);
}
```

---

### Пример: безопасно въвеждане на масив от N елемента

```cpp
#include <vector>

vector<int> readArray(int n) {
    if (n < 0 || n > 1'000'000)
        throw invalid_argument("Невалиден размер на масива");

    vector<int> a; a.reserve(n);
    for (int i = 0; i < n; ++i) {
        a.push_back(readInt()); // от по-горе
    }
    return a; // без `new`/`delete` → по-безопасно
}
```

---
# Добри практики

---

### Правила

* **Валидирайте възможно най-рано** (на входа на функцията).
* Давайте **ясни съобщения** при грешка (какво, защо, как да се поправи).
* Предпочитайте **типове от стандартната библиотека** (`std::string`, `std::vector`).
* Използвайте изключения за **извънредни ситуации**, не за нормален контрол на потока.
* Не хвърляйте/улавяйте изключения по **стойност** → използвайте `const &`.
* При ресурси – използвайте **RAII** (`std::unique_ptr`, `std::fstream`).

---

### Проверка срещу изключения

| Подход               | Кога             | Плюсове             | Минуси                      |
| -------------------- | ---------------- | ------------------- | --------------------------- |
| Проверки (if/return) | Често            | Ясни и евтини       | Разпилян код при много нива |
| Изключения           | Рядко/извънредно | Централизиран catch | Скъпи при хвърляне          |

---

# Пример: меню с валидиран вход

---

```cpp
#include <iostream>
#include <limits>
using namespace std;

int readMenuChoice(int lo, int hi) {
    while (true) {
        cout << "Изберете [" << lo << "-" << hi << "]: ";
        int c;
        if (cin >> c && c >= lo && c <= hi) return c;
        cout << "Невалиден избор. Опитайте пак.\n";
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
    }
}

int main() {
    cout << "1) Сумиране\n2) Изваждане\n3) Изход\n";
    int choice = readMenuChoice(1,3);
    cout << "Вие избрахте: " << choice << "\n";
}
```
---
## Пример

- Имаме следната функция. Кой е най-добрият начин да я валидираме?

```cpp
int divide(int a, int b)
{
	return a / b;
}
```
---
### 1. Връщане на специална стойност

```cpp
int divide(int a, int b)
{
    if (b == 0)
        return -1;  // код за грешка
    return a / b;
}

int main()
{
    int res = divide(10, 0);
    if (res == -1)
        cout << "Грешка: деление на нула\n";
    else
        cout << "Резултат: " << res << endl;
}
```
---
- **Предимства:**
    - Много просто, работи навсякъде.
- **Недостатъци:**
    - Не винаги има “свободна” стойност за грешка (напр. ако всяка стойност е валидна).
    - Не можеш да разбереш _каква_ е грешката (само че е имало такава).
---
### 2. Връщане на код за грешка чрез параметър (по референция или пойнтър)

```cpp
bool divide(int a, int b, int& result)
{
    if (b == 0)
        return false;  // грешка
    result = a / b;
    return true;       // успех
}

int main()
{
    int res;
    if (divide(10, 0, res))
        cout << "Резултат: " << res << endl;
    else
        cout << "Грешка: деление на нула\n";
}
```
---
- **Предимства:**
    - Можеш да върнеш _и резултат_, _и код за грешка_.
    - Ясна проверка чрез `if`.
- **Недостатъци:**
    - Кодът става по-дълъг и по-труден за четене.
    - Изисква допълнителен параметър.
---
### 3. Връщане на структура / `struct` с резултат и код

```cpp
struct Result {
    bool success;
    int value;
    string error;
};

Result divide(int a, int b)
{
    if (b == 0)
        return {false, 0, "Деление на нула"};
    return {true, a / b, ""};
}

int main()
{
    Result r = divide(10, 0);
    if (r.success)
        cout << "Резултат: " << r.value << endl;
    else
        cout << "Грешка: " << r.error << endl;
}
```
---
- **Предимства:**
    - Ясна структура на връщаните данни.
    - Може да съдържа повече информация за грешката.

- **Недостатъци:**
     - Изисква повече писане и поддръжка.
---
### 4. Чрез изключения (`throw` / `catch`)

```cpp
#include <stdexcept>
#include <iostream>
using namespace std;

int divide(int a, int b)
{
    if (b == 0)
        throw invalid_argument("Деление на нула");
    return a / b;
}

int main()
{
    try {
        cout << divide(10, 0) << endl;
    } catch (const invalid_argument& e) {
        cout << "Грешка: " << e.what() << endl;
    }
}
```
---
- **Предимства:**
    - Разделя нормалния поток на изпълнение от обработката на грешки.
    - Може да пренася много информация за грешката.
- **Недостатъци:**
    - По-бавно при често хвърляне.
    - По-сложно за начинаещи.
---
### 5. Модерен вариант – `std::optional` (C++17)

```cpp
#include <optional>
#include <iostream>
using namespace std;

optional<int> divide(int a, int b)
{
    if (b == 0)
        return nullopt; // няма стойност
    return a / b;
}

int main()
{
    auto res = divide(10, 0);
    if (res.has_value())
        cout << "Резултат: " << *res << endl;
    else
        cout << "Грешка: деление на нула\n";
}
```
---
- **Предимства:**
    - Много чист и безопасен синтаксис.
    - Без нужда от допълнителни структури.

- **Недостатъци:**
    - Работи само ако „липсата на резултат“ е достатъчна като сигнал (без детайли за грешката).
---
# Чести капани

---

* Забравено `cin.clear()` и `ignore()` → безкраен цикъл.
* При `std::getline` след `cin >>` – остава `\n` в буфера → използвайте `ignore()`.
* `throw;` вътре в `catch` прехвърля текущото изключение (без аргумент!).
* **Не хвърляйте** от деструктори; при нужда – логвайте.

---

# Мини-проекти

---

1. **Калкулатор на оценки**: чете N оценки (0–100), валидира входа, изчислява средно. Грешки → съобщения.
2. **Резервационна система**: парсира дата във формат `DD.MM.YYYY`, валидира диапазони (1–31/1–12/1900–2100), хвърля подходящи изключения.
3. **Конфигурационен парсер**: чете ключ=стойност, валидира типове (int/bool/string); при грешен ред – `invalid_argument`.
4. **Меню с подменюта**: устойчиво към грешен вход; използва `readMenuChoice`.
5. **Функция `safe_div`**: деление с изключение при нула и тестове с гранични случаи.

---
# Задачи

---

1. Напишете функция `readDouble()` с валидиране и съобщения за грешка.
2. Създайте `readIntInRange(lo, hi)` и използвайте я за въвеждане на възраст (0–130).
3. Имплементирайте `parseIndex(s, size)` → парсва цяло число и хвърля `out_of_range` ако е извън `[0, size)`.
4. Напишете клас `ValidationError` и го използвайте в функция за валидиране на имена (само букви и тире, дължина 2–30).
5. Реализирайте програма, която чете N и после N цели числа; при невалиден ред – изкарва съобщение и **повторно** иска само сбъркания елемент.
